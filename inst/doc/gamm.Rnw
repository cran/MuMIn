\documentclass{article}
\usepackage[utf8]{inputenc}
\addtolength{\textwidth}{1.25in}
\addtolength{\oddsidemargin}{-.75in}
\setlength{\evensidemargin}{\oddsidemargin}

%\VignettePackage{MuMIn}
%\VignetteIndexEntry{Model selection with GAMM}
%\VignetteDepends{mgcv,gamm4}

\usepackage{url}
\newcommand{\code}[1]{{\tt #1}}
\newcommand{\pkg}[1]{{\tt #1}}
\newcommand{\sQuote}[1]{{`#1'}}
\newcommand{\dQuote}[1]{{``#1''}}

\title{Model selection using GAMM with \pkg{MuMIn} }
\date{\today}
\author{Kamil Barto≈Ñ}
\begin{document}
\maketitle

<<echo=FALSE,eval=TRUE,results=hide>>=
suppressPackageStartupMessages(suppressWarnings({
library(gamm4)
library(mgcv)
library(MuMIn)
}))

set.seed(0)
@

\section{Extending \pkg{MuMIn}'s functionality to support \code{gamm} }

This document describes how to implement the interface between the routines
performing model selection and averaging in \pkg{MuMIn} and a class of models
not supported by default, using \code{gamm} from package \pkg{mgcv} as
an example.

The two principal functions in \pkg{MuMIn}, \code{model.avg} and \code{dredge}
rely on the availability of methods for several generic functions for the class
of the given fitted model object.
These generic functions include the ones defined in package \code{stats}
(\code{logLik}, \code{formula}, \code{nobs},
and optionally \code{deviance} which may simply return \code{NULL}), as well
as ones defined in \pkg{MuMIn} itself (\code{coeffs},
\code{getAllTerms} and \code{coefTable}). In some cases the default methods may
work as well.

In the case of \code{gamm} and \code{gamm4}, the returned object has no special
class, and it is a \code{list} with two items: \code{lme} or \code{mer}, and
\code{gam} (with some information stripped from it). Therefore no specific
methods can be applied.

The solution is to provide a \sQuote{wrapper} function for \code{gamm} that evaluates
the model and adds a class attribute onto it, e.g.:
<<results=hide>>=
gamm <-
    function(...)
    structure(c(mgcv::gamm(...), list(call=match.call(mgcv::gamm))),
	class=c("gamm", "list"))
@
similarly for \code{gamm4} (but assign the same class \code{gamm}):
<<results=hide>>=
gamm4 <-
    function(...)
    structure(c(gamm4::gamm4(...), list(call=match.call(gamm4::gamm4))),
	class=c("gamm", "list"))
@

As these wrappers have the same names as the actual functions, use of them is
invisible for the user, and they mask the original functions on the level of
\code{.GlobalEnv}.

In addition, these wrappers add a \code{call} element, containing the original
call to the wrapper function. It is not necessary, but makes things easier later
on for \code{dredge}.

Once we have an object of class \code{gamm}, it is possible to provide methods
for it. First let us define the generic methods from \pkg{stats}.

<<results=hide>>=
logLik.gamm <-
    function (object, ...) logLik(object[[if(is.null(object$lme))
    "mer" else "lme"]], ...)
formula.gamm <-
    function (x, ...) formula(x$gam, ...)
nobs.gamm <-
    function (object, ...)  nobs(object$gam, ...)
@

It should be noted here that the issue of what the log-likelihood for GAMM
should be is not entirely clear. The documentation for \code{gamm} states that
the log-likelihood of \code{lme} is not the one of the fitted GAMM. However,
comparing alternative models presents some evidence that it may be still
appropriate for \code{gamm}. Namely both the log-likelihood of fitted
\code{lme}, and one of the \code{lme} part of \code{gamm} (including only linear
terms to make the comparison adequate) have identical values.

<<>>=

dat <- gamSim(6,n=100,scale=.2,dist="normal")
fm1 <- gamm(y~x0+x1+x2+x3,data=dat,random=list(fac=~1), method="ML")
fm2 <- lme(y~x0+x1+x2+x3,data=dat,random=list(fac=~1), method="ML")

logLik(fm1$lme)
logLik(fm2)
@

Likewise is in the generalised case of \code{gamm4} and \code{lmer}:
<<>>=
dat <- gamSim(6,n=100,scale=.2,dist="poisson")
fmg1 <- gamm4(y ~ x0+x1+x2+x3, family=poisson, data=dat,random=~ (1|fac))
fmg2 <- lmer(y ~ x0+x1 + x2 + x3 + (1|fac), family=poisson, data=dat)

logLik(fmg1$mer)
logLik(fmg2)
@

A comparison of \code{gamm4} including a smooth term with fixed two degrees
of freedom gives log-likelihood which is very close to that of \code{lmer}
including a linear and quadratic term.

<<>>=

fmgs1 <- gamm4(y ~ x0+ s(x1, k=3, fx=TRUE)+ x2+ x3, family=poisson, data=dat,
	random=~ (1|fac))
fmgs2 <- lmer(y ~ x0+ x1 + I(x1^2) + x2+ x3 + (1|fac), family=poisson, data=dat)
logLik(fmgs1$mer)
logLik(fmgs2)

@

Normally, the object returned by \code{gam} inherits also from glm, so the
\code{nobs} method for \code{glm} is called, but in case of \code{gamm} the
\code{gam} element has only class \code{gam}, so we need to define the method
directly (it just calls \code{nobs.glm}):

<<results=hide>>=
nobs.gam <- function (object, ...)  stats:::nobs.glm(object, ...)
@

Methods for generic functions defined in \pkg{MuMIn}:
<<results=hide>>=
coeffs.gamm <- function (model) coef(model$gam)
getAllTerms.gamm <- function (x, ...) getAllTerms(x$gam, ...)
coefTable.gamm <- function (model, ...) coefTable(model$gam, ...)
@
Two columns are obligatory in the \code{data.frame} returned by
\code{coefTable}: \sQuote{Estimate} and \sQuote{Std. Error}).

\section{Model selection}

Now we have all the prerequisites to proceed with the model selection:

<<>>=

set.seed(0)
dat <- gamSim(6, n=100, scale=5, dist="normal")

fmgs2 <- gamm(y ~1+ s(x0)+ s(x3) + s(x2), family=gaussian, data=dat,
	random = list(fac=~1))
@
This model fits poorly, but this is deliberate, to justify the model averaging.

<<>>=
head(dd2 <- dredge(fmgs2))
@
(Note that we get quite different results using \code{gamm4})

<<>>=

summary(model.avg(dd2, subset= cumsum(weight) <= .95))

@

\end{document}
